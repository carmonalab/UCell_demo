---
title: UCell demo
author: 
- Massimo Andreatta^[massimo.andreatta@unil.ch]
- Santiago Carmona^[santiago.carmona@unil.ch]
date: "15/02/2021"
knit: (function(input_file, encoding) {
  out_dir <- 'docs';
  rmarkdown::render(input_file,
 encoding=encoding,
 output_file=file.path(dirname(input_file), out_dir, 'index.html'))})
#output: html_notebook
---


Checks to do:

* Reproducibility, changing seeds, chunk size, ncores
* Accept matrix/data.frame with gene names as row names, convertible into data.table; sce object
* check presence of features and inform % missing and that all absent will be considered as 0


```{r message=F, warning=F}
#renv::restore()
library(ggplot2)
library(plotly)
#remotes::install_github("mojaveazure/seurat-disk")
library(SeuratDisk)
library(Seurat)
#remotes::install_git("https://gitlab.unil.ch/carmona/UCell.git")
#remotes::install_git("git@gitlab.unil.ch:carmona/UCell.git")

system("R CMD build ../UCell")
system("R CMD INSTALL UCell_0.2.0.tar.gz")

library(UCell)
library(BiocManager)
library(AUCell)
```

#Limit amount of available memory (simulate smaller machine)

I cannot find a way to do this interactively
But we can set a memory limit in .Renviron (local for this project) to e.g. R_MAX_VSIZE=8Gb
Then re-run code, to see the effect on performance
#NB! remember to comment out R_MAX_VSIZE after you're done!

Also consider variable R_GC_MEM_GROW:
"The strategy used for growth can be specified by setting the environment variable R_GC_MEM_GROW to an integer value between 0 and 3. This variable is read at start-up. Higher values grow the heap more aggressively, thus reducing garbage collection time but using more memory."

Run gc(): you will see that "gc trigger", the threshold of memory that prompts garbage collection, is equal to the limit in Mb for a small machine (e.g. 8GB). It's tricky to set a good value for R_GC_MEM_GROW because "gc trigger" depends on current load on the system and will change with time...


```{r}
Sys.getenv("R_MAX_VSIZE")
Sys.getenv("R_GC_MEM_GROW")
```

Load a large atlas for benchmarking
```{r}
make_sets=F
load_seurat=F
if (make_sets) {
  pbmc.azimuth.full <- LoadH5Seurat("../Azimuth/data/pbmc_multimodal.h5seurat")
  exp.matrix <- pbmc.azimuth.full@assays$SCT@counts
  
  seurat <- CreateSeuratObject(counts = exp.matrix)
  saveRDS(seurat, file="data/pbmc.seurat.4bench.rds")
  saveRDS(exp.matrix, file="data/pbmc.expmat.rds")
} else {
  if (load_seurat) {
     seurat <- readRDS("data/pbmc.seurat.4bench.rds")
     exp.matrix <- seurat@assays$RNA@counts
  } else {
     exp.matrix <- readRDS("data/pbmc.expmat.rds")
  }
}

```

Problem: complete seurat object is 7.5GB, expression matrix is 3.8GB. There are very large objects on a small machine, and may
distort the memory benchmark for small subsamples. Possible solution, reload at each step only the sub-object with the size to be evaluated, and discard 
the complete object. Also test effect on gc trigger, since less memory is used just to store the large initial objects.

#See notebook UCell_benchmarks.small.machines.Rmd for an implementation that only load the needed object into memory (instead of subsetting a very large object)
```{r}
gc()
i.samp <- 100
this.data <- exp.matrix[,1:100]
exp.matrix <- NULL
gc()

```

Define signatures for human T cell subtypes
```{r, eval=T}
HCA.markers.Hs.Tcell <- list()
HCA.markers.Hs.Tcell$Tcell_CD4 <- c("CD4","CD40LG")
HCA.markers.Hs.Tcell$Tcell_CD8 <- c("CD8A","CD8B")
HCA.markers.Hs.Tcell$Tcell_Treg <- c("FOXP3","IL2RA")
HCA.markers.Hs.Tcell$Tcell_MAIT <- c("KLRB1", "SLC4A10", "NCR3")
HCA.markers.Hs.Tcell$Tcell_gd <- c("TRDC", "TRGC1", "TRGC2", "TRDV1")
HCA.markers.Hs.Tcell$Tcell_NK <- c("FGFBP2", "SPON2", "KLRF1", "FCGR3A", "KLRD1", "TRDC")
saveRDS(HCA.markers.Hs.Tcell,"data/HCA.markers.Hs.Tcell.PBMC.RData")
```

Is gc() doing what it is supposed to?
We measure everything that happens between gc1 and gc2
```{r}
cat("Load an object (memory in MB)\n")
gc1 <- gc(reset = TRUE)

tmp <- as.matrix(exp.matrix[,1:2000])

gc2 <- gc()
memPeak <- sum(gc2[,7]) - sum(gc1[,7])
memPeak

cat("Load a second object (memory in MB)\n")
gc1 <- gc(reset = TRUE)

tmp <- as.matrix(exp.matrix[,1:1000])

gc2 <- gc()
memPeak <- sum(gc2[,7]) - sum(gc1[,7])
memPeak

cat("Load a second object while keeping the first in memory\n")
gc1 <- gc(reset = TRUE)

tmp <- as.matrix(exp.matrix[,1:2000])
tmp2 <- as.matrix(exp.matrix[,1:1000])

gc2 <- gc()
memPeak <- sum(gc2[,7]) - sum(gc1[,7])
memPeak

cat("Before loading the second object, free up memory from the first. Max remains memory of first (larger) object\n")
gc1 <- gc(reset = TRUE)

tmp <- as.matrix(exp.matrix[,1:2000])
tmp <- NULL
invisible(gc())
tmp2 <- as.matrix(exp.matrix[,1:1000])

gc2 <- gc()
memPeak <- sum(gc2[,7]) - sum(gc1[,7])
memPeak

cat("Free up memory at the end of call. Should not affect max memory usage\n")
gc1 <- gc(reset = TRUE)

tmp <- as.matrix(exp.matrix[,1:2000])
tmp2 <- as.matrix(exp.matrix[,1:1000])
tmp <- NULL
invisible(gc())

gc2 <- gc()
memPeak <- sum(gc2[,7]) - sum(gc1[,7])
memPeak

cat("Load same object several times. We are only interested in dimension of object, but we forget to clean up\n")
gc1 <- gc(reset = TRUE)

dims <- as.list(rep(0, 10))
a <- lapply(dims, function(i) {
   tmp <- as.matrix(exp.matrix[,1:2000])
   toreturn <- dim(tmp)[1]
   return(toreturn) 
} )

gc2 <- gc()
memPeak <- sum(gc2[,7]) - sum(gc1[,7])
memPeak

cat("Load same object several times. We are only interested in dimension of object, and we do clean up unneeded data\n")
#Peak usage remains the price of loading a single object
gc1 <- gc(reset = TRUE)

dims <- as.list(rep(0, 100))
a <- lapply(dims, function(i) {
   tmp <- as.matrix(exp.matrix[,1:2000])
   
   toreturn <- dim(tmp)[1]
   
   tmp <- NULL
   invisible(gc())
   return(toreturn)  
} )

gc2 <- gc()
memPeak <- sum(gc2[,7]) - sum(gc1[,7])
memPeak


cat("Load same object several times. let gc() be invoked automatically\n")
gc1 <- gc(reset = TRUE)

dims <- as.list(rep(0, 100))
a <- lapply(dims, function(i) {
   tmp <- as.matrix(exp.matrix[,1:2000])
   
   toreturn <- dim(tmp)[1]
   return(toreturn)  
} )

gc2 <- gc()
memPeak <- sum(gc2[,7]) - sum(gc1[,7])
memPeak
```


AUCell breaks from 10,000 cells on simulated small machine (8 GB RAM)
AUCell breaks from 50,000 cells on simulated intermediate machine (16 GB RAM)
AUCell breaks with 150,000 cells even on very large machine (128 GB RAM)
```{r eval=T}
library(tidyr)
dim(exp.matrix)
dim(seurat)

seurat <- NULL   #Free up this memory if using small machine

#testSamp <- c(100,1000,2000,3000)
#testSamp <- c(100,1000,2000,5000, 1e4)
testSamp <- c(100, 200, 500, 1000, 2000, 5000, 1e4, 2e4, 5e4, 1e5)
chunk.size <- 1000
force.gc <- FALSE
#gcinfo(TRUE)

features <- HCA.markers.Hs.Tcell
  
time_table <- matrix(NA,nrow = length(testSamp),ncol = 3)
colnames(time_table) <- c("size","AUCell","UCell")

memory_table <- matrix(NA,nrow = length(testSamp),ncol = 3)
colnames(memory_table) <- c("size","AUCell","UCell")

for (i in seq_along(testSamp)[]){
  i.samp <- testSamp[i]
  time_table[i,1] <- i.samp
  memory_table[i,1] <- i.samp
  this.data <- exp.matrix[,1:i.samp]
  
  print(i.samp)
  
  
  gc1 <- gc(reset = TRUE)
  t <- system.time({
    
    out <- tryCatch({
       scores_UCell <- ScoreSignatures_UCell(this.data, features = features, chunk.size = chunk.size, force.gc = force.gc)
       1
    },
    error=function(cond) {
      message(cond)
      return(NA)
    })
  })
  gc2 <- gc()
  if (is.na(out)) { #Out of memory
    memPeak <- NA
    time <- NA
  } else {
    memPeak <- sum(gc2[,7]) - sum(gc1[,7])
    time <- t[["elapsed"]]
  }
  
  time_table[i,3] <- time
  memory_table[i,3] <- memPeak
  
  gc1 <- gc(reset = TRUE)
  t <- system.time({
    
    out <- tryCatch({
      cells_rankings <- AUCell_buildRankings(this.data, nCores = 1, plotStats = F)
      cells_AUC <- AUCell_calcAUC(features, cells_rankings, aucMaxRank=1000)
      scores_AUC <- as.data.frame(t(getAUC(cells_AUC)))
      1
    },
    error=function(cond) {
      message(cond)
      return(NA)
    })
    
  })
  gc2 <- gc()
  if (is.na(out)) { #Out of memory
    memPeak <- NA
    time <- NA
  } else {
    memPeak <- sum(gc2[,7]) - sum(gc1[,7])
    time <- t[["elapsed"]]
  }
  
  time_table[i,2] <- time
  memory_table[i,2] <- memPeak
  
  
}
#gcinfo(FALSE)

#Print results
time_table.df <- time_table %>% as.data.frame() %>% pivot_longer(-size,values_to="time") 
memory_table.df <- memory_table %>% as.data.frame() %>% pivot_longer(-size,values_to="memory") 
memory_table.df$memory <- memory_table.df$memory/1000  #Convert to Gb

colors <- c("#eba223","#23a5eb")
ggplot(time_table.df, aes(x=size, y = time, name)) +  geom_point(aes(color = name)) + 
  scale_x_log10() + scale_y_log10() + xlab("Size (# cells)") + ylab("Time (seconds)") + 
  scale_color_manual(values=colors) + theme_bw()
ggsave("plots/benchmark_time_direct.16GB.png", height=4, width=5)


ggplot(memory_table.df, aes(x=size, y = memory, name)) +  geom_point(aes(color = name)) + 
  scale_x_log10() + scale_y_log10() + xlab("Size (# cells)") + ylab("Memory (GB)") + 
  scale_color_manual(values=colors) + theme_bw()
ggsave("plots/benchmark_mem_direct.16GB.png", height=4, width=5)

```



Benchmark with ranks pre-computing

#Note: AddModuleScore fails when few cells are provided (e.g. 100), not enough to compute 'bins'

```{r}
#testSamp <- c(100,1000,2000,3000)
testSamp <- c(1000, 2000, 5000, 1e4)
#testSamp <- c(100, 200, 500, 1000, 2000, 5000, 1e4, 2e4, 5e4, 1e5)

chunk.size <- 1000

features <- HCA.markers.Hs.Tcell

time_table <- matrix(NA,nrow = length(testSamp),ncol = 4)
colnames(time_table) <- c("size","AUCell","UCell","AddModuleScore")

memory_table <- matrix(NA,nrow = length(testSamp),ncol = 4)
colnames(memory_table) <- c("size","AUCell","UCell","AddModuleScore")

for (i in seq_along(testSamp)[]){
  i.samp <- testSamp[i]
  time_table[i,1] <- i.samp
  memory_table[i,1] <- i.samp

  
  this.obj <- seurat[,1:i.samp]
  this.exp <- this.obj@assays$RNA@counts
  
  ranks_UCell <- StoreRankings_UCell(this.exp, maxRank = 1000, chunk.size = chunk.size)
  ranks_AUCell <-  AUCell_buildRankings(this.exp, nCores = 1, plotStats = F)

  print(i.samp)
  
  #RUN UCell
  gc1 <- gc(reset = TRUE)
  t <- system.time({
    scores_UCell <- ScoreSignatures_UCell(matrix=NULL, features=features, precalc.ranks=ranks_UCell,
                                          maxRank = 1000, chunk.size=chunk.size)
  })
  gc2 <- gc()
  memPeak <- sum(gc2[,7]) - sum(gc1[,7])
  
  time_table[i,3] <- t[["elapsed"]]
  memory_table[i,3] <- memPeak
  
  #RUN AUCell
  gc1 <- gc(reset = TRUE)
  t <- system.time({
    cells_AUC <- AUCell_calcAUC(features, ranks_AUCell, aucMaxRank=1000)
    scores_AUC <- as.data.frame(t(getAUC(cells_AUC)))
  })
  gc2 <- gc()
  memPeak <- sum(gc2[,7]) - sum(gc1[,7])
  
  time_table[i,2] <- t[["elapsed"]]
  memory_table[i,2] <- memPeak
  
 #RUN AddModuleScore
  gc1 <- gc(reset = TRUE)
  t <- system.time({
       obj_modulescore <- AddModuleScore(this.obj, features = features)
  })
  gc2 <- gc()
  memPeak <- sum(gc2[,7]) - sum(gc1[,7])
  
  time_table[i,4] <- t[["elapsed"]]
  memory_table[i,4] <- memPeak
  
}

time_table.df <- time_table %>% as.data.frame() %>% pivot_longer(-size,values_to="time") 
memory_table.df <- memory_table %>% as.data.frame() %>% pivot_longer(-size,values_to="memory") 
memory_table.df$memory <- memory_table.df$memory/1000  #Convert to Gb

colors <- c("#78eb23","#eba223","#23a5eb")
ggplot(time_table.df, aes(x=size, y = time, name)) +  geom_point(aes(color = name)) + 
  scale_x_log10() + scale_y_log10() + xlab("Size (# cells)") + ylab("Time (seconds)") + 
  scale_color_manual(values=colors) + theme_bw()
ggsave("plots/benchmark_time_precomp.png")

ggplot(memory_table.df, aes(x=size, y = memory, name)) +  geom_point(aes(color = name)) + 
  scale_x_log10() + scale_y_log10() + xlab("Size (# cells)") + ylab("Memory (GB)") + 
  scale_color_manual(values=colors) + theme_bw()
ggsave("plots/benchmark_memory_precomp.png")


```


Multi-core benchmark
```{r eval=T}
library(parallel)
library(doParallel)
library(doRNG)
library(tidyr)
#testSamp <- c(100,1000,2000,3000)
testSamp <- c(100, 1000, 2000, 5000, 1e4, 1e5)
chunk.size <- 1000
ncores <- 4

features <- HCA.markers.Hs.Tcell
  
time_table <- matrix(NA,nrow = length(testSamp),ncol = 3)
colnames(time_table) <- c("size","AUCell","UCell")

memory_table <- matrix(NA,nrow = length(testSamp),ncol = 3)
colnames(memory_table) <- c("size","AUCell","UCell")

for (i in seq_along(testSamp)[]){
  i.samp <- testSamp[i]
  time_table[i,1] <- i.samp
  memory_table[i,1] <- i.samp
  this.data <- exp.matrix[,1:i.samp]
  
  print(i.samp)
  
  gc1 <- gc(reset = TRUE)
  t <- system.time({
    scores_UCell <- ScoreSignatures_UCell(this.data, features = features, chunk.size = chunk.size, ncores=ncores)
  })
  gc2 <- gc()
  memPeak <- sum(gc2[,7]) - sum(gc1[,7])
  
  time_table[i,3] <- t[["elapsed"]]
  memory_table[i,3] <- memPeak
  
  gc1 <- gc(reset = TRUE)
  t <- system.time({
    cells_rankings <- AUCell_buildRankings(this.data, nCores = ncores, plotStats = F)
    cells_AUC <- AUCell_calcAUC(features, cells_rankings, aucMaxRank=1000)
    scores_AUC <- as.data.frame(t(getAUC(cells_AUC)))
  })
  gc2 <- gc()
  memPeak <- sum(gc2[,7]) - sum(gc1[,7])
  
  time_table[i,2] <- t[["elapsed"]]
  memory_table[i,2] <- memPeak

}

#Print results
time_table.df <- time_table %>% as.data.frame() %>% pivot_longer(-size,values_to="time") 

ggplot(time_table.df, aes(x=size, y = time, name)) +  geom_point(aes(color = name))
ggsave("plots/benchmark_time_multicore.png", height=4, width=5)
memory_table.df <- memory_table %>% as.data.frame() %>% pivot_longer(-size,values_to="memory") 

ggplot(memory_table.df, aes(x=size, y = memory, name)) +  geom_point(aes(color = name)) + ylim(c(0,NA))
ggsave("plots/benchmark_mem_multicore.png", height=4, width=5)

```




Benchmark using Rprof (does not account for memory deallocations)
```{r eval=F}
testSamp <- c(100, 1000, 2000, 5000, 1e4, 1e5)
#testSamp <- c(1e3,5e3,1e4)

features <- HCA.markers.Hs.Tcell
  
time_table <- matrix(NA,nrow = length(testSamp),ncol = 3)
colnames(time_table) <- c("size","AUCell","UCell")

memory_table <- matrix(NA,nrow = length(testSamp),ncol = 3)
colnames(memory_table) <- c("size","AUCell","UCell")

for (i in seq_along(testSamp)[]){
  i.samp <- testSamp[i]
  time_table[i,1] <- i.samp
  memory_table[i,1] <- i.samp
  
  this.data <- exp.matrix[,1:i.samp]
  
  print(i.samp)
  Rprof(tf <- "rprof.log", memory.profiling=TRUE)
  t <- system.time({
    cells_rankings <- AUCell_buildRankings(this.data,nCores = 1, plotStats = F)
    cells_AUC <- AUCell_calcAUC(features, cells_rankings, aucMaxRank=1000)
    cells_AUC.num <- as.data.frame(t(getAUC(cells_AUC)))
    obj_out1 <- AddMetaData(obj,cells_AUC.num)
    })
  Rprof(NULL)
  
  memPeak <- max(summaryRprof("Rprof.log", memory="both")$by.total$mem.total)
  time_table[i,2] <- t[["elapsed"]]
  memory_table[i,2] <- memPeak
  
  print(obj_out1@meta.data[1:5,])
  
  Rprof(tf <- "rprof.log", memory.profiling=TRUE)
  t <- system.time({
    obj_out2 <- AddModuleScore_UCell(this.data, features = features, maxRank = 1000)
  })
  Rprof(NULL)
  
  memPeak <- max(summaryRprof("Rprof.log", memory="both")$by.total$mem.total)  
  time_table[i,3] <- t[["elapsed"]]
  memory_table[i,3] <- memPeak
  
}

#Print results
time_table.df <- time_table %>% as.data.frame() %>% pivot_longer(-size,values_to="time") 

ggplot(time_table.df, aes(x=size, y = time, name)) +  geom_point(aes(color = name))
#ggsave("plots/benchmark_time_Rprof.png", height=4, width=5)
memory_table.df <- memory_table %>% as.data.frame() %>% pivot_longer(-size,values_to="memory") 

ggplot(memory_table.df, aes(x=size, y = memory, name)) +  geom_point(aes(color = name)) + ylim(c(0,NA))
#ggsave("plots/benchmark_mem_Rprof.png", height=4, width=5)


```

